PROJECT: SARM Protocol (Stablecoin Automated Risk Management Protocol)

CONTEXT:
This project is being built for ETHGlobal Buenos Aires 2025. The main goal is to:
- Build a technically strong, production-grade Uniswap v4 Hook for stablecoin markets.
- Compete for and win prizes in:
  1) Uniswap v4 Stable-Asset Hooks track
  2) Chainlink bounty (using S&P Global stablecoin ratings on-chain)
  3) The Graph bounty (risk analytics / dashboards / subgraphs)

The project name is:
- SARM Protocol = Stablecoin Automated Risk Management protocol

We are using:
- Solidity
- Foundry (NOT Hardhat)
- Uniswap v4 core + hooks
- Chainlink (S&P Global Stablecoin Stability Assessment feeds via DataLink)
- The Graph (for analytics / dashboards) – this part comes later, but is important context.

We want Copilot to help write high-quality Solidity code, tests, and basic scripts for this protocol.

------------------------------------------------------------
HIGH-LEVEL IDEA

Problem:
- Stablecoins have real and non-trivial depeg risk (USDC depeg during SVB, UST collapse, etc.).
- LPs in stablecoin pools often get wrecked when a stablecoin loses its peg; fees and AMM curves do not dynamically reflect institutional risk or changing conditions.
- There is now an institutional-grade, on-chain signal of stablecoin risk: S&P Global Stablecoin Stability Assessments (SSA), delivered on-chain via Chainlink DataLink on Base.
- However, AMMs like Uniswap currently do not integrate these ratings directly into their liquidity, fees or risk controls.

Solution:
- SARM Protocol is a Uniswap v4 Hook that makes stablecoin liquidity "risk-aware".
- It reads S&P Global Stablecoin Stability Assessment (SSA) ratings via Chainlink, caches them on-chain, and uses them to:
  - Adjust pool fees dynamically based on stablecoin risk.
  - Enforce risk modes and circuit breakers when ratings degrade (e.g. rating goes from 2 to 4).
  - Optionally, tailor the pricing curve / slippage limits for stablecoin pairs.
- On top of the hook, we will index events and state with The Graph to drive a risk dashboard:
  - Which pools are in "normal" mode vs "risk" mode.
  - How often ratings changed.
  - How fees responded to rating changes.
  - LP-side analytics: what would have happened with vs without SARM.

The Uniswap v4 Stable-Asset Hooks track explicitly wants:
- Hooks designed for stable-asset markets.
- Novel applications of hooks for synthetic lending, credit-backed trading, or optimized stable AMM logic.

SARM fits this perfectly:
- It is an optimized stable AMM risk layer, informed by institutional ratings (S&P) and delivered via Chainlink.
- It can be extended to credit-backed trading and sophisticated risk overlays.

------------------------------------------------------------
ETHGLOBAL / PRIZE CONTEXT (BRIEF SUMMARY)

Uniswap v4 Stable-Asset Hooks prize:
- 1st: $4,000
- 2nd: $2,000 ×2
- 3rd: $1,000 ×2
- Focus: Uniswap v4 hooks for stable-asset markets; real ecosystem need ("this should exist"), technical execution, and clear presentation.

Chainlink bounty (simplified):
- Must use a Chainlink service inside on-chain logic that causes a state change.
- Bonus for using multiple Chainlink services in a meaningful way.
- In our case:
  - Use S&P Global SSA feeds via Chainlink DataLink on-chain.
  - Potentially use Chainlink Automation to refresh cached ratings periodically.
  - Optionally use Chainlink CRE (Cloud Runtime Environment) to orchestrate workflows.

The Graph bounty (simplified):
- Best use of Amp datasets and/or subgraphs for analytics, AI, or advanced query features.
- We will build a subgraph and/or analytics layer on top of SARM events and pool data.

Technical constraints:
- No UI is strictly required by Uniswap, but our project SHOULD have at least a minimal dashboard to improve clarity and help with judging (clarity/presentation and The Graph bounty).
- The core MUST be solid Solidity code + tests + clear README.

------------------------------------------------------------
ARCHITECTURE OVERVIEW

Tooling:
- Foundry
- Uniswap v4 core and hooks packages (import from official repos)
- OpenZeppelin contracts (ERC20, Ownable, etc.)

We are NOT using Hardhat. Everything should be compatible with Foundry:
- `src/` for contracts
- `test/` for Forge tests
- `script/` for deployment scripts (optional)
- `lib/` for external dependencies (Uniswap, OZ, etc.)

Core on-chain architecture (Phase 1):

1) SSAOracleAdapter (Solidity contract)
   - Responsibility:
     - Single source of truth for stablecoin ratings on-chain.
     - Interface between Chainlink SSA feeds and the SARM Hook.
   - Functionality:
     - Store rating per token, plus lastUpdated timestamp.
     - Allow reading rating:
       - `function getRating(address token) external view returns (uint8 rating, uint256 lastUpdated);`
     - Allow refreshing rating via Chainlink:
       - `function refreshRating(address token) external;`
         - Read from SSA Chainlink feed (or DataLink adapter).
         - Normalize rating to 1-5 scale.
         - Update storage.
         - Emit `RatingUpdated(token, oldRating, newRating)`.
     - For development/demo:
       - A manual setter restricted to owner (for tests and live demo simulations):
         - `function setRatingManual(address token, uint8 rating) external onlyOwner;`
   - Data:
     - mapping(address => uint8) public tokenRating;
     - mapping(address => uint256) public tokenRatingLastUpdated;
     - mapping(address => address) public tokenToFeed; // Chainlink feed address per token.

   - Phase 1:
     - Implement manual ratings (no Chainlink yet) to unblock SARMHook development and tests.
   - Phase 2:
     - Wire actual Chainlink feed interface and integrate `refreshRating`.

2) SARMHook (Uniswap v4 Hook: core of the protocol)
   - Responsibility:
     - Implement Uniswap v4 hook logic that:
       - Reads ratings from SSAOracleAdapter.
       - Computes an effective rating for the pool (e.g. max(r0, r1) over token0/token1).
       - Applies dynamic fees, risk modes, and optional circuit breakers.
   - It should implement the appropriate Uniswap v4 Hook interfaces (beforeSwap, possibly beforeSwapReturnDelta, etc.).
   - Configuration:
     - A RiskConfig struct holding thresholds (e.g. low/medium/high risk).
     - Mappings of which pools are governed by SARM.
   - Basic logic (MVP):
     - On beforeSwap:
       - Identify pool's token0 and token1.
       - Query ratings r0, r1 from SSAOracleAdapter.
       - Compute effectiveRating = max(r0, r1).
       - Decide:
         - Swap allowed or reverted (simple circuit breaker if rating >= HIGH_RISK threshold).
         - Fee tier to apply based on rating (risk-adjusted dynamic fee).
       - Emit events for transparency:
         - `FeeUpdated(pool, oldFee, newFee, effectiveRating)`
         - `RiskModeChanged(pool, newMode)` (NORMAL / RISK / FROZEN)
   - Extended logic (stretch goals):
     - Use `beforeSwapReturnDelta` to implement custom pricing curve behavior tailored to stablecoins and risk.
     - Implement multiple modes:
       - NORMAL: low fees, normal limits.
       - ELEVATED_RISK: higher fees, tighter slippage / trade size limits.
       - FROZEN: big swaps blocked, maybe only small "exit" trades allowed.

3) MockERC20 tokens for testing
   - Simple ERC20 tokens with mint() for local testing (e.g., MockUSDC, MockUSDT).
   - Used to create a stablecoin pair pool for testing SARMHook.

Later components (Phase 2/3):

4) Chainlink Integration
   - Real Chainlink SSA feeds wired into SSAOracleAdapter:
     - Each supported stablecoin has a feed address.
   - Optionally:
     - Chainlink Automation to call refreshRating periodically.
   - For the hackathon:
     - At minimum, implement the interface and logic in SSAOracleAdapter to read from a mock or testnet SSA feed, and document how it would connect to real ones.

5) The Graph Subgraph
   - Index:
     - RatingUpdated events (token ratings over time).
     - FeeUpdated, RiskModeChanged events.
     - Swap events from the Uniswap v4 pool(s) under SARM.
   - Expose:
     - Pool-level risk history.
     - Fee vs rating evolution.
     - LP oriented metrics:
       - Fraction of time spent in each risk mode.
       - Volume under each rating band.

6) Frontend (simple risk dashboard)
   - A minimal web UI is planned but not strictly required by Uniswap.
   - It will:
     - Show pools protected by SARM.
     - Display current rating per token and current fee mode.
     - Visualize rating history vs fee changes.
     - Demo a simulated downgrade: showing how SARM responds in real time (fee change, risk mode, logs).

------------------------------------------------------------
IMPLEMENTATION PHASES (FOR COPILOT TO RESPECT)

PHASE 0 – PROJECT BOOTSTRAP
- Create a Foundry project.
- Add dependencies for:
  - Uniswap v4 core and hooks (using git submodules or Foundry remappings).
  - OpenZeppelin contracts.
- Ensure basic test compiles and runs.

PHASE 1 – CORE HOOK + MANUAL RATINGS
- Implement SSAOracleAdapter with manual rating setter (no Chainlink yet).
- Implement SARMHook wired to the adapter:
  - beforeSwap logic:
    - read ratings for token0/token1
    - compute effectiveRating
    - apply simple risk policy (e.g. revert swaps when effectiveRating >= threshold)
  - Add events for debugging and analytics.
- Write Forge tests to validate:
  - Swaps allowed under low-risk ratings.
  - Swaps reverted / limited under high-risk ratings.
  - Events are emitted correctly.

PHASE 2 – DYNAMIC FEES
- Extend SARMHook:
  - Add a function mapping rating -> fee tier.
  - On beforeSwap, compute and apply a dynamic fee depending on rating.
- Write tests to ensure:
  - Correct fee tier is applied for each rating scenario.
  - Fees change when ratings change.

PHASE 3 – CHAINLINK INTEGRATION
- Implement Chainlink SSA feed interface within SSAOracleAdapter.
- Support mapping from token to feed address.
- Implement refreshRating() to update tokenRating based on feed data.
- Write tests with a mock Chainlink feed contract (simulating different SSA values).

PHASE 4 – ANALYTICS + FRONTEND (LATER)
- Define events for The Graph indexing (already done in previous phases).
- Build a subgraph schema around:
  - Tokens, Pools, Ratings, RiskEvents, FeeEvents.
- Basic frontend reading from the subgraph or directly from the chain.

------------------------------------------------------------
STYLE AND QUALITY EXPECTATIONS FOR CODE

- Clear separation of responsibilities:
  - SSAOracleAdapter does not implement hook behavior.
  - SARMHook does not directly talk to Chainlink; it only consumes ratings via the adapter.
- Strong tests using Foundry (Forge):
  - Unit tests for SSAOracleAdapter.
  - Unit/integration tests for SARMHook with a local Uniswap v4 pool and mock tokens.
- Readable, documented Solidity:
  - NatSpec comments for key contracts and functions.
  - Well-named events, enums, and structs.
- Security-minded:
  - Use Ownable or proper access control on rating setters.
  - Avoid unnecessary external calls inside the critical hook path; use caching (ratings ideally updated off path via refreshRating).
- Remember: this is a hackathon, but the target is "this could be incubated and run in production".

END OF CONTEXT FILE.
